<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Oyunu</title>
    <style>
        @font-face {
            font-family: 'Digital-7';
            src: url('https://db.onlinewebfonts.com/t/8e22783d707ad140bffe18b2a3812529.woff2') format('woff2');
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: black;
            overflow: hidden;
            font-family: 'Digital-7', monospace;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
        }
        
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let score = 0;
        let autoClickerLevel = 0;
        let passiveIncomeLevel = 0;
        let autoClickerCost = 10;
        let passiveIncomeCost = 20;
        let passiveIncomeLevel2 = 0;
        let passiveIncomeCost2 = 100;
        let passiveIncomeLevel3 = 0;
        let passiveIncomeCost3 = 500;
        let rotationAngle = 0;

        let flyingScores = [];

        const button = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: Math.min(canvas.width, canvas.height) * 0.15
        };

        const autoClickerButton = {
            x: canvas.width * 0.50,
            y: canvas.height * 0.70,
            width: canvas.width * 0.45, 
            height: canvas.height * 0.05 
        };

        const passiveIncomeButton = {
            x: canvas.width * 0.5,
            y: canvas.height * 0.77,
            width: canvas.width * 0.45, 
            height: canvas.height * 0.05 
        };

        const passiveIncomeButton2 = {
            x: canvas.width * 0.5,
            y: canvas.height * 0.84,
            width: canvas.width * 0.45, 
            height: canvas.height * 0.05 
        };

        const passiveIncomeButton3 = {
            x: canvas.width * 0.5,
            y: canvas.height * 0.91,
            width: canvas.width * 0.45, 
            height: canvas.height * 0.05 
        };

        const characters = '10';
        const drops = [];
        const dropCount = 100;
        for (let i = 0; i < dropCount; i++) {
            drops.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                length: Math.floor(Math.random() * 15) + 5, 
                speed: Math.random() * 4 + 2 
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            score += passiveIncomeLevel * 0.1;
            score += passiveIncomeLevel2 * 0.15;
            score += passiveIncomeLevel3 * 0.2;
            drops.forEach(drop => {
                drop.y += drop.speed;
                if (drop.y > canvas.height) {
                    drop.y = 0;
                    drop.x = Math.random() * canvas.width;
                }
            });

            flyingScores = flyingScores.filter(fs => {
                fs.y -= 2;
                fs.opacity -= 0.02;
                return fs.opacity > 0;
            });
        }

        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = `${canvas.width * 0.02}px Digital-7`;
            drops.forEach(drop => {
                for (let i = 0; i < drop.length; i++) {
                    const char = characters[Math.floor(Math.random() * characters.length)];
                    const alpha = 1 - (i / drop.length);
                    ctx.fillStyle = `rgba(255, 153, 0, ${alpha})`;
                    ctx.fillText(char, drop.x, drop.y - i * 20);
                }
            });
            ctx.save();


            
            ctx.beginPath();
            ctx.arc(button.x, button.y, button.radius, 0, Math.PI * 3);
            ctx.fill();
            // Rotating Lines Animation (NOW FILLING THE BUTTON)
            ctx.translate(button.x, button.y);
            ctx.rotate(rotationAngle);

            for (let i = 0; i < 15; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const lineLength = button.radius + (i * 0,1);
                ctx.lineTo(0, lineLength);

                const alpha = 1 - (i / 11);
                ctx.strokeStyle = `rgba(255, 204, 0, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.rotate(Math.PI / 5);
            }

            // Restore the context state to remove the clipping
            ctx.restore(); 
            rotationAngle += 0.03; 

            ctx.fillStyle = '#FF9900';
            ctx.font = `bold ${canvas.width * 0.09}px Digital-7`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black'; 
            ctx.lineWidth = 1; 
            ctx.strokeText(`score: ${Math.floor(score)}`, canvas.width / 2, canvas.height * 0.1);
            ctx.fillText(`score: ${Math.floor(score)}`, canvas.width / 2, canvas.height * 0.1);
            
            const buttonRadius = Math.min(autoClickerButton.width, autoClickerButton.height) * 0.2;
            
            ctx.shadowColor = '#FFCC00';
            ctx.shadowBlur = 10;

            ctx.fillStyle = '##FF9900';
            drawRoundedRect(autoClickerButton.x - autoClickerButton.width / 2, autoClickerButton.y, autoClickerButton.width, autoClickerButton.height, buttonRadius);
            ctx.fill();
            drawRoundedRect(passiveIncomeButton.x - passiveIncomeButton.width / 2, passiveIncomeButton.y, passiveIncomeButton.width, passiveIncomeButton.height, buttonRadius);
            ctx.fill();
            drawRoundedRect(passiveIncomeButton2.x - passiveIncomeButton2.width / 2, passiveIncomeButton2.y, passiveIncomeButton2.width, passiveIncomeButton2.height, buttonRadius);
            ctx.fill();
            drawRoundedRect(passiveIncomeButton3.x - passiveIncomeButton3.width / 2, passiveIncomeButton3.y, passiveIncomeButton3.width, passiveIncomeButton3.height, buttonRadius);
            ctx.fill();

            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#000000';
            ctx.font = `${canvas.width * 0.025}px Digital-7`; 
            ctx.textAlign = 'center';
            ctx.fillText(`virtual hand (${autoClickerLevel})`, autoClickerButton.x, autoClickerButton.y + autoClickerButton.height / 2); 
            ctx.fillText(`cost: ${autoClickerCost}`, autoClickerButton.x, autoClickerButton.y + autoClickerButton.height * 0.85); 
            ctx.fillText(`digital self (${passiveIncomeLevel})`, passiveIncomeButton.x, passiveIncomeButton.y + passiveIncomeButton.height / 2); 
            ctx.fillText(`cost: ${passiveIncomeCost}`, passiveIncomeButton.x, passiveIncomeButton.y + passiveIncomeButton.height * 0.85); 
            ctx.fillText(`automation systems (${passiveIncomeLevel2})`, passiveIncomeButton2.x, passiveIncomeButton2.y + passiveIncomeButton2.height / 2); 
            ctx.fillText(`cost: ${passiveIncomeCost2}`, passiveIncomeButton2.x, passiveIncomeButton2.y + passiveIncomeButton2.height * 0.85); 
            ctx.fillText(`artificial intelligence (${passiveIncomeLevel3})`, passiveIncomeButton3.x, passiveIncomeButton3.y + passiveIncomeButton3.height / 2); 
            ctx.fillText(`cost: ${passiveIncomeCost3}`, passiveIncomeButton3.x, passiveIncomeButton3.y + passiveIncomeButton3.height * 0.85); 

            flyingScores.forEach(fs => {
                ctx.fillStyle = `rgba(255, 153, 0, ${fs.opacity})`;
                ctx.font = `bold ${canvas.width * 0.04}px Digital-7`;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(`+${fs.value}`, fs.x, fs.y);
                ctx.fillText(`+${fs.value}`, fs.x, fs.y);
            });
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width    / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    // Ana butona tıklama kontrolü
    if (Math.hypot(x - button.x, y - button.y) < button.radius) {
        score += 1 + autoClickerLevel;
        flyingScores.push({
            x: x,
            y: y,
            value: 1 + autoClickerLevel,
            opacity: 1
        });
    }

    // Otomatik Tıklayıcı butonuna tıklama kontrolü
    if (x > autoClickerButton.x - autoClickerButton.width / 2 &&
        x < autoClickerButton.x + autoClickerButton.width / 2 &&
        y > autoClickerButton.y &&
        y < autoClickerButton.y + autoClickerButton.height) {
        if (score >= autoClickerCost) {
            score -= autoClickerCost;
            autoClickerLevel++;
            autoClickerCost *= 2;
        }
    }

    // Pasif Gelir butonuna tıklama kontrolü
    if (x > passiveIncomeButton.x - passiveIncomeButton.width / 2 &&
        x < passiveIncomeButton.x + passiveIncomeButton.width / 2 &&
        y > passiveIncomeButton.y &&
        y < passiveIncomeButton.y + passiveIncomeButton.height) {
        if (score >= passiveIncomeCost) {
            score -= passiveIncomeCost;
            passiveIncomeLevel++;
            passiveIncomeCost *= 2;
        }
    }
    // Pasif Gelir butonuna tıklama kontrolü
    if (x > passiveIncomeButton2.x - passiveIncomeButton2.width / 2 &&
        x < passiveIncomeButton2.x + passiveIncomeButton2.width / 2 &&
        y > passiveIncomeButton2.y &&
        y < passiveIncomeButton2.y + passiveIncomeButton2.height) {
        if (score >= passiveIncomeCost2) {
            score -= passiveIncomeCost2;
            passiveIncomeLevel2++;
            passiveIncomeCost2 *= 3;
        }
    }
    // Pasif Gelir butonuna tıklama kontrolü
    if (x > passiveIncomeButton3.x - passiveIncomeButton3.width / 2 &&
        x < passiveIncomeButton3.x + passiveIncomeButton3.width / 2 &&
        y > passiveIncomeButton3.y &&
        y < passiveIncomeButton3.y + passiveIncomeButton3.height) {
        if (score >= passiveIncomeCost3) {
            score -= passiveIncomeCost3;
            passiveIncomeLevel3++;
            passiveIncomeCost3 *= 2;
        }
    }
});

gameLoop();
    </script>
</body>
</html>

